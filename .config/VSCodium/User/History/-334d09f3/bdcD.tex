\documentclass[10pt,a4paper,twoside]{article}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage{hyperref}
\usepackage{csquotes}
\usepackage{float}
\usepackage{multicol}
\usepackage{color}
\usepackage{mathtools}
\usepackage{colortbl}
\usepackage{xcolor}
\usepackage{hhline}
\usepackage{titling}



\MakeOuterQuote{"}
\setlength\parindent{0pt}
\newcommand{\defeq}{\vcentcolon=}
\numberwithin{equation}{section}
\setcounter{secnumdepth}{3} % seting level of numbering (default for "report" is 3). With ''-1'' you have non number also for chapters
 %\setcounter{tocdepth}{5} % if you want all the levels in your table of contents
\hypersetup{colorlinks=true, linkcolor=black, citecolor=black} 
 
 
\date{18 octobre 2022} 
\author{
		Marc-Olivier Jufer \\
		\begin{normalsize}23P\end{normalsize}\\
		\begin{normalsize} Gymnase de Bienne et du Jura Bernois \end{normalsize}\\
			\begin{normalsize} Sous le mentorat de Enea Milio \end{normalsize}
			\vspace{2 cm}
}
		
\title{	\includegraphics[scale=10]{logo_fr.png}\\
		\vspace{2 cm}
		Comment sécuriser le vote électronique grâce à la blockchain\\ 
		\begin{large} 
			Travail de maturité en informatique
		\end{large} 
		\vspace{2 cm}
}

\begin{document}
	
	\begin{titlingpage}		
		\maketitle		
		\vspace{2 cm}
		\begin{abstract}
	Ce travail de maturité a pour but d’éclaircir deux concepts prenant de plus en plus d’ampleur dans notre société
et avec lesquels nous devrons à l’avenir tenir compte : le vote électronique et la blockchain. Nous allons expliquer ces
deux concepts afin de mieux les comprendre et essayer de répondre à la question suivante : comment peut-on sécuriser le vote électronique en utilisant la blockchain. Pour ceci, nous présentons le système utilisé pour les élections de l'EPFL. Nous expliquons également de manière vulgarisée les principes mathématiques qui permettent à ces technologies de fonctionner.
\end{abstract}	
		
	\end{titlingpage}
	
	
	\tableofcontents
	
	
\newpage	

	
\section{Le vote électronique}
	Le vote électronique est un système de vote automatisé et dématérialisé. Un tel système offre plusieurs avantages, notamment la simplicité de voter (entre autres l'impossibilité de soumettre un suffrage nul), la possibilité de voter à distance et le comptage automatique (donc plus rapide et plus fiable que le comptage manuel)\cite{wiki:Vote_electronique}\cite{chf}.

	\subsection{Historique}
		La première technologie automatique créée dans le but de faciliter les votations est apparue en 1910 et a été inventée par Eugenio Boggiano. Il s'agissait en fait d'une urne automatique mécanique. Le premier système largement utilisé est celui des urnes électroniques, apparues dans les années 1990 et utilisé encore aujourd'hui par beaucoup de pays dont les États-Unis, la France ou encore l'Inde. Notons que l'urne électronique n'est pas un système dématérialisé, il n'intègre donc que certains des avantages cités précédemment : le comptage est automatisé et il n'est pas possible d'émettre un suffrage nul. En revanche, les électeurs doivent tout de même se rendre dans un bureau de vote pour pouvoir voter \cite{wiki:Vote_electronique}.\\
		
		L'Estonie est l'un des seuls pays à utiliser le vote par Internet, grâce à un système dont une partie du code source a été publié, mais qui manque toujours de transparence selon plusieurs observateurs. \cite{wiki:Vote_electronique}
	
	\subsection{Qualités requises pour un système de vote} \label{critères}
		Pour qu'un système de vote soit considéré comme bon, il doit avoir les qualités suivantes \cite{dvoting} 
		\begin{itemize}
			\item Confidentialité : personne ne doit pouvoir avoir connaissance du vote des électeurs (sauf eux-mêmes).
			\item Authenticité : il doit être possible de vérifier que les électeurs sont bien des personnes autorisées à prendre part à la votation.
			\item Fiabilité : chaque électeur doit pouvoir vérifier à tout moment que son vote a été correctement pris en compte.
			\item Disponibilité : Un électeur légitime ne doit pas se voir refuser la possibilité de voter.
		\end{itemize} 
	\subsection{Le vote électronique en Suisse}
		En Suisse, la possibilité d'automatiser les processus de votations et d'élections grâce à l'informatique est envisagée depuis 2004. L'un des systèmes qui a fait le plus parler est celui développé par La Poste, entreprise suisse. Après avoir été soumis à un processus de contrôle par des experts indépendants, ce système a été jugé trop peu fiable pour être utilisé pour le moment. Après cette tentative et bien d'autres, le vote électronique n'est toujours pas disponible aujourd'hui en Suisse. La Poste est toujours en train d'améliorer son système \cite{chf}.\\
		
		Depuis le 1er juillet 2022, la législation permet de nouveau aux cantons de proposer le vote électronique dans le cadre d'un scrutin fédéral après demande au Conseil fédéral. Ces lois obligent les potentiels futurs systèmes de vote à être contrôlés par des experts indépendants et à être soumis à des programmes de bug bounty\footnote{Un bug bounty (littéralement "prime à la faille") est un programme qui récompense toute personne trouvant une faille dans un système informatique.}. Les lois régissant le vote électronique sont l'Art. 27 a-o de l'Ordonnance sur les droits politiques  (ODP - RS 161.11) et l'Ordonnance de la Chancellerie fédérale sur le vote électronique (OVotE - RS 161.116) \cite{chf}.
		
		
		\subsection{Projet Helios}
			La société Helios a développé un système de vote à audit ouvert. Cela signifie que les votants peuvent vérifier que leur vote a été déposé correctement, que tous les votes sont visibles par tous (sous forme cryptée, de manière à respecter la confidentialité des votants) et tout le monde peut vérifier que les votes soumis ont bien été pris en compte \cite{wiki:Helios_voting}.\\
			
			La principale différence entre ce système et celui présenté dans la \autoref{alltogether} réside dans le fait qu'il faut faire confiance à un serveur centralisé dans la solution proposée par Helios.
			

\section{Rappels techniques et mathématiques}
	
	\subsection{Différents modèles de réseau}
		\paragraph{Client-serveur} \label{client-server}
			Le modèle de réseau client-serveur est celui de la plupart des réseaux que nous utilisons aujourd'hui : le client envoie des requêtes au serveur et le serveur réceptionne ces requêtes et y répond. Les rôles sont bien définis et tous les clients dépendent d'un serveur central, auquel les utilisateurs du réseau sont obligés de faire confiance.
		
		\paragraph{Peer-to-peer} \label{P2P}
			Dans un réseau construit sur le modèle du peer-to-peer (pair-à-pair en français), chaque n\oe ud est à la fois client et serveur. Dans ce réseau, chaque n\oe ud est un client qui dépend du reste du réseau et est en même temps un serveur qui fournit des services au reste du réseau \cite{wiki:p2p}. Ce système est particulièrement adapté dans un contexte où on ne peut faire confiance à personne, comme nous allons le voir par la suite.
		
		\begin{figure}[H] \label{network_models}
			\centering
			\begin{multicols}{2}
				\includegraphics[width=\linewidth]{client-server-network.png}\par
				\includegraphics[width=\linewidth]{P2P-network.png}\par
			\end{multicols}
			\caption{Réseau construit sur le modèle client-serveur à gauche et peer-to-peer à droite (source : \cite{wiki:p2p})}
		\end{figure}

	\subsection{Fonctions de hashage} \label{hash}
		Les fonctions de hashages sont des fonctions très utilisées en cryptographie. Leur qualité principale est qu'il n'existe pas de réciproque pour une fonction de hashage : on peut passer facilement de $x$ à $f(x)$ mais il n'existe pas de moyen mathématique de passer de $f(x)$ à $x$. La seule possibilité pour retrouver $x$ à partir de $f(x)$ est de calculer $f(x)$ pour toutes les valeurs possibles pour $x$ et de comparer les résultats. Cette qualité est très utile pour le stockage des mots de passe : lorsque vous créez un compte sur un site internet correctement sécurisé, votre mot de passe n'est pas stocké en clair dans la base de données. Il est d'abord hashé (passé dans une fonction de hashage) et on stocke le hash (la sortie de la fonction), également appelé empreinte numérique, dans la base de données. Cela empêche une personne ayant accès à la base de données de voir votre mot de passe. Cette qualité est également utile dans le processus de preuve de travail (voir \autoref{PoW}) \cite{fonctions_hashage} \cite{wiki:fonctions_hashage}.\\
		
		Une autre qualité des fonctions de hashage est la grande différence qu'il y a entre les hash de deux éléments presque identiques. Ainsi, lorsqu'on passe le texte \textit{texte1} dans la fonction SHA256, une des fonctions de hashage les plus utilisées, on obtient le résultat \textit{f1d5af3f2c6829a4bbbea7df2a510e01fa457b620c4600ca6aa022e91a3a63aa} alors que lorsqu'on soumet \textit{texte2} on obtient \textit{67f8f3e13cf7303fa2bdc131e41e9fa2c81a29c7092cfddce3f346a543a952be}. Cette propriété est utile lorsqu'on veut contrôler qu'un logiciel téléchargé en ligne est le même que celui proposé par le développeur, on peut passer l'exécutable téléchargé dans une fonction de hashage et le comparer au hash mis en ligne par le développeur. Une toute petite différence dans le code sera très facile à remarquer en comparant les hash\cite{fonctions_hashage} \cite{wiki:fonctions_hashage}.\\
		
	
	\subsection{Arithmétique modulaire} \label{modular_arithmetic}
		L'arithmétique modulaire est un système d'arithmétique sur des nombres entiers avec lequel on fait des calculs sur les restes de divisions euclidiennes par un nombre appelé module \cite{wiki:modular_arithmetic}.
		\paragraph{Exemple}
			Le reste de la division euclidienne de 18 par 7 est 4 ($18 = 2 \cdot 7 + \textbf{4}$). On dit alors que 18 modulo 7 = 4
		\paragraph{Définitions}
			La division euclidienne d'un nombre $a$ par un nombre $n$ donne un reste $r$. Cela veut dire que $a = k\cdot n + r$ pour $k \in \mathbb{R}$. On l'écrit comme cela :
			\begin{equation}
				a\ mod\ n = r
			\end{equation}
			Lorsque deux nombres $a$ et $b$ ont le même reste $r$ après la division par un nombre $n$, on dit qu'ils sont \textit{congrus modulo m}. On écrit
			\begin{equation}
				a \equiv b \pmod n
			\end{equation}
			Il est facile de se représenter l'arithmétique modulaire en en illustrant une utilisation fréquente dans la vie de tous les jours : le calcul des heures sur une horloge. Avec comme module $n = 12$, on voit que 9h + 4h = 1h, ce qui s'écrit formellement $9 + 4 \equiv 1 \pmod{12}$.
			
			\begin{figure}[H] \label{clock}
				\centering
				\includegraphics[width = 7cm]{clock.png}
				\caption{Exemple d'utilisation de l'arithmétique modulaire sur une horloge (source : \cite{wiki:modular_arithmetic})}
			\end{figure}
			
		\paragraph{Restes négatifs}
			Le reste est toujours un nombre entier, mais il peut aussi être négatif. En fait, chaque reste peut être exprimé par un nombre positif ou négatif. En reprenant l'exemple de l'horloge, en partant de zéro, on arrive à la même heure lorsqu'on remonte le temps de trois heures ou qu'on avance de neuf. On voit donc que $-3$ et $9$ sont congrus modulo $12$.
			\begin{equation}
				-3 \equiv 9 \pmod{12}
			\end{equation}

		\subsubsection{Inverse multiplicatif modulaire} \label{inverse}
			En mathématique classique, l'inverse multiplicatif est l'entier $b$ qui, lorsqu'il multiplie $a$, donne un résultat de 1.
			\begin{equation}
				ab = 1
			\end{equation}\\
			
			L'inverse multiplicatif modulaire est son analogue en arithmétique modulaire : le produit de $a$ et $b$ est congru à 1 au modulo $m$. On l'écrit comme cela :
			\begin{equation}
				ab \equiv 1 \pmod m
			\end{equation}\\
			
			\paragraph{Calcul par force brute} La manière de calculer l'inverse modulaire qui demande le moins de réflexion de la part d'un humain ayant un ordinateur à disposition est la recherche par force brute : on essaye chaque nombre entre $2$ et $m$ et on vérifie si leur produit donne $1$. Cette façon de faire demande beaucoup de puissance de calcul car elle implique un algorithme en complexité $O(m)$ : le nombre d'opérations nécessaires pour le calcul grandit de façon linéaire par rapport au modulo $m$.
			
			\paragraph{Algorithme d'Euclide étendu}
				On peut calculer l'inverse modulaire de $a$ modulo $m$ beaucoup plus efficacement en utilisant l'algorithme d'Euclide étendu.\\
				L'algorithme d'Euclide permet de trouver le plus grand diviseur commun (pgdc) de deux nombres sans passer par la décomposition en facteurs premiers. Cet algorithme se base sur la proposition suivante : "Si $a$ et $b$ sont deux nombres naturels et que $r$ est le reste de la division de $a$ par $b$ ($a \equiv r \pmod b$), le pgdc de $a$ et $b$ est égal au pgdc de $b$ et $r$ ($pgdc(a,b) = pgdc(b,r)$)" \cite{wiki_algorithme_euclide}. En voici un exemple :
				\begin{table}[H] 
					\centering
					\begin{tabular}{|c|c|c|c|c|c|}
						\hline
						\rowcolor{gray!40} $n$ & $r_{n-1}$ & $r_n$ & $r_{n-1} = r_n q_n + r_{n+1}$ & $q_n$ & $r_{n+1}$\\
						\hline
						$1$ & $91$ & $63$ & $91 = 1 \cdot 63 + 28$ & $1$ & $28$ \\
						\hline
						$2$ & $63$ & $28$ & $63 = 2 \cdot 28 + 7$ & $2$ & \cellcolor{yellow!40} $7$ \\
						\hline
						$3$ & $28$ & $7$ & $28 = 4 \cdot 7 + 0$ & $4$ & $0$ \\
						\hline
						$4$ & $7$ & $0$ & & & \\
						\hline
					\end{tabular}
					\caption{Exemple d'algorithme d'Euclide pour trouver le pgdc de 122 et 39} \label{example_pgdc}
				\end{table}
				Le dernier reste non nul (ici $7$) est le plus grand diviseur commun.\\
				
				L'algorithme d'Euclide étendu calcule les coefficients de Bézout en plus du plus grand diviseur commun. Lorsqu'on a trouvé le plus grand diviseur commun de deux nombres $a$ et $b$, on peut toujours trouver deux entiers (positifs ou négatifs) $x$ et $y$ qui, lorsqu'on les multiplie par $a$, respectivement par $b$, donne le pgdc de $a$ et $b$. Les coefficients de Bézout sont ces deux entiers $x$ et $y$ \cite{wiki_algorithme_euclide_etendu}.
				\begin{equation}
					ax + by = pgdc(a,b)
				\end{equation}
				Lorsque $a$ et $b$ sont premiers entre eux ($pgdc(a,b) = 1$), on obtient l'équation suivante :
				\begin{equation}\label{ax+by=1}
					ax + by = 1
				\end{equation}
				On voit donc facilement que $x$ est l'inverse multiplicatif modulaire de $a$ au modulo $b$ et y est l'inverse multiplicatif modulaire de $b$ au modulo $a$. Voici le développement à partir de l'\autoref{ax+by=1}.
				\begin{equation}
					ax \equiv ax \pmod b\ ;\ by \equiv 0 \pmod b\ ;\ 1 \equiv 1 \pmod b \\					
					\Rightarrow ax \equiv 1 \pmod b \Rightarrow x \equiv a^{-1} \pmod b
				\end{equation}
				 \begin{equation}
				 	ax \equiv 0 \pmod a\ ;\ by \equiv by \pmod a\ ;\ 1 \equiv 1 \pmod a \\
				 	\Rightarrow by \equiv 1 \pmod a \Rightarrow y \equiv b^{-1} \pmod a
				 \end{equation}
				 Prenons l'exemple des nombres $a = 54$ et $b = 19$. Le calcul du pgdc par l'algorithme d'Euclide donne ceci : 
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|c|c|c|c|c|c|}
				 		\hline
				 		\rowcolor{gray!40} $n$ & $r_{n-1}$ & $r_n$ & $r_{n-1} = r_nq_n + r_{n+1}$ & $q_n$ & $r_{n+1}$\\
				 		\hline
				 		$1$ & $54$ & $19$ & $54 = 19 \cdot 2 + 16$ & $2$ & $16$ \\
				 		\hline
				 		$2$ & $19$ & $16$ & $19 = 16 \cdot 1 + 3$ & $1$ & $3$ \\
				 		\hline
				 		$3$ & $16$ & $3$ & $16 = 3 \cdot 5 + 1$ & $5$ & \cellcolor{yellow!40} $1$\\
				 		\hline
				 		$4$ & $3$ & $1$ & $3 = 1 \cdot 3 + 0$ & $3$ & $0$\\
				 		\hline
				 	\end{tabular}
				 	\caption{Exemple d'algorithme d'Euclide pour trouver le pgdc de 54 et 19} \label{example_pgdc2}
				 \end{table}
				 Dans le \autoref{example_pgdc2}, le reste ($r_{n+1}$) peut toujours être défini comme $r_{n+1} = r_{n-1} - q_n \cdot r_n$ (reste = dividende $-$ quotient $\cdot$ diviseur). On peut également réécrire le reste comme $r = ax + by$. En mettant le tout dans un tableau en rajoutant quelques colonnes pour des calculs intermédiaires on obtient :
				 \begin{table}[H]
				 	\centering
				 	\begin{tabular}{|c|c|c|cccccccc|}
				 		\hline
				 		\rowcolor{gray!40} $r$ & & & $=$ & $x$ & $\cdot$ & $a$ & $+$ & $y$ & $\cdot$ & $b$ \\
				 		\hline
				 		$54$ & & & $=$ & $1$ & $\cdot$ & $54$ & $+$ & $0$ & $\cdot$ & $19$ \\
				 		\hline
				 		$19$ & & & $=$ & $0$ & $\cdot$ & $54$ & $+$ & $1$ & $\cdot$ & $19$\\
						\hline				 	
						$16$ & $ = 54 - 2\cdot 19$ & & $=$ & $1$ & $\cdot$ & $54$ & $+$ & $-2$ & $\cdot$ & $19$ \\
						\hline
						$3$ & $ = 19 - 1\cdot 16$ & $ = 1\cdot 19 - 1 \cdot (1 \cdot 54 - 2 \cdot 19)$ & $=$ & $-1$ & $\cdot$ & $54$ & $+$ & $3$ & $\cdot$ & $19$ \\
						\hline
						$1$ & $ = 16 - 5\cdot 3$ & $ = (1\cdot 54 - 2\cdot 19) - 5(-1\cdot 54 + 3\cdot 19)$ & $=$ & \cellcolor{yellow!40}$6$ & $\cdot$ & $54$ & $+$ & \cellcolor{yellow!40}$-17$ & $\cdot$ & $19$\\
						\hline
				 	\end{tabular}
				 	\caption{Exemple d'algorithme d'Euclide étendue pour trouver les coefficients de Bézout}
				 \end{table}
				Dans la troisième colonne de la dernière ligne, on reprend les valeurs qu'on a déjà calculées et inscrites dans la colonne de droite, $16 = 54 - 2\cdot 19$ et $3 = -1\cdot 54 + 3\cdot 19$.\\
				
				On lit sur la dernière ligne que les coefficients de Bézout sont $x = 6$ et $y = -17$, on sait donc que $6 \equiv 54^{-1} \pmod{19}$ et que $-17 \equiv 19^{-1} \pmod{54}$. 
				
		
		\subsubsection{Logarithme discret} \label{discrete_log}
			Le logarithme discret est, en arithmétique modulaire, l'analogue du logarithme réel pour l'ensemble $\mathbb{R}$. \\
			Lorsqu'on prend, avec le modulo $n$, un groupe de nombres $G$ compris entre $1$ et $n-1$, chaque élément $x$ de $G$ peut être décrit sous la forme $x = b^k$ (ou $k \in \mathbb{Z}$). $b$ est appelé générateur s'il rempli cette condition. Pour simplifier, nous allons dire que le générateur doit être un nombre premier non diviseur de $n-1$. Le logarithme discret est l'entier $k$ vérifiant cette propriété et étant compris entre $0$ et $n$, ce qui en fait la réciproque de l'exponentiation pour le modulo $n$ \cite{wiki:logarithme_discret}.
			\paragraph{Exemple}
				En prenant comme modulo 5 et avec comme générateur 3, on obtient pour les exponentiations : $3^0 \equiv 1 \pmod 5$ ; $3^1 \equiv 3 \pmod 5$ ; $3^2 \equiv 4 \pmod 5$ ; $3^3 \equiv 2 \pmod 5$ ; $3^4 \equiv 1 \pmod 5$ ; $3^5 \equiv 3 \pmod 5$ ; ...
				\begin{table}[H]
					\centering			
					\begin{tabular}{|c|c|c|c|c|c|c|c|}
						\hline
						\rowcolor{gray!40} $3^0$ & $3^1$ & $3^2$ & $3^3$ & $3^4$ & $3^5$ & $3^6$ & $\cdots$ \\
						\hline
						$1$ & $3$ & $4$ & $2$ & $1$ & $3$ & $4$ & $\cdots$ \\
						\hline
						
					\end{tabular}
					\caption{Résultats de l'exponentiation de $3$ au modulo $5$}
				\end{table}
				On voit que les résultats des exponentiations forment une suite répétitive. On peut donc dire qu'il existe une infinité d'exposants $k$ qui vérifient la propriété $3^k \equiv 1 \pmod 5$ et le résultat du logarithme discret est simplement le plus petit de ces nombres.
				\begin{table}[H]
					\centering
					\begin{tabular}{|c|c|c|c|c|}
						\hline
						\rowcolor{gray!40} $x$ & $1$ & $2$ & $3$ & $4$ \\
						\hline
						$ \log_3 x$ & $0$ & $3$ & $1$ & $2$\\
						\hline
					\end{tabular}
					\caption{Résultats des logarithmes discrets en base $3$ au modulo $5$}
				\end{table}
				
			Il n'existe aucun algorithme beaucoup plus efficace que la recherche par force brute permettant de calculer le logarithme discret, alors qu'il est très facile de calculer l'exponentielle, ce qui est une propriété intéressante pour des applications cryptologiques.
				
	\subsection{Chiffrement ElGamal} \label{elgamal}
		Le chiffrement ElGamal est un protocole de chiffrement asymétrique construit sur le principe du logarithme discret \cite{wiki:chiffrement_elgamal}. \\
		Un chiffrement symétrique utilise la même clé pour chiffrer et déchiffrer les données (un des exemples les plus simples est le chiffre de Jules César, où la clé est simplement le nombre de décalages et ne change pas entre le chiffrage et le déchiffrage). Le plus grand problème de ce type de chiffrement est que les deux parties doivent d'abord se rencontrer afin de pouvoir s'échanger une clé pour ensuite communiquer de manière sécurisée. Le chiffrement asymétrique résout ce problème. Contrairement au chiffrement symétrique, il utilise deux différentes clés : une pour le chiffrement (la clé publique) et une pour le déchiffrement (la clé privée). Chaque personne qui veut pouvoir recevoir des messages cryptés met à disposition de tout le monde sa clé publique, mais garde sa clé privée pour elle seule. Grâce à quelques astuces mathématiques, le message peut être crypté avec la clé publique et décrypté avec la clé privée. Il est impossible de retrouver la clé privée à partir de la clé publique, ce qui permet de pouvoir échanger des messages de manière sécurisée sans avoir besoin de se retrouver pour échanger les clés secrètement, étant donné que les clés publiques (les seules utiles pour le chiffrement) sont mises à disposition de tout le monde. Les deux algorithmes de cryptage asymétrique les plus connus sont RSA, qui base sa sécurité sur la difficulté à décomposer un grand nombre en facteurs premiers et ElGamal, basé sur le problème du logarithme discret.\\
		Les algorithmes de chiffrement asymétrique sont souvent très lourds à exécuter. C'est pourquoi ils sont principalement utilisés dans des systèmes hybrides entre cryptographie asymétrique et symétrique : le protocole asymétrique est utilisé pour chiffrer la clé (afin de ne pas devoir se retrouver en personne pour échanger les clés) d'un protocole symétrique qui va chiffrer les messages \cite{wiki:cryptographie_hybride}.
		
		\subsubsection{Description de l'algorithme}
			Selon Wikipedia \cite{wiki:chiffrement_elgamal}, l'algorithme de chiffrement ElGamal est décrit comme cela : \\
			
			Soit une transmission d'un message $M$ entre Alice et Bob avec Eve comme personne malveillante voulant lire le message.
			Le chiffrement ElGamal peut se décomposer en trois méthodes : la génération des clés, le chiffrement et le déchiffrement.
			\paragraph{Génération des clés}
				\begin{itemize}
					\item Alice choisi un modulo $p$ et un générateur $g$ (le résultat de toutes les opérations suivantes sera donc toujours au modulo p).
					\item Elle choisi un entier $x$ au hasard tel que $1 \leq x \leq p-1$
					\item Elle définit $h \defeq g^x$
					\item Alice publie la clé publique qui contient les valeurs $(p,g,h)$ et garde $x$ comme sa clé privée
				\end{itemize}
				
			\paragraph{Chiffrement}
				Bob veut envoyer un message en utilisant la clé publique d'Alice. Il connaît donc $(p,g,h)$ et $M$ (le message qu'il veut envoyer).
				\begin{itemize}
					\item Bob transforme le message $M$ en un nombre $m$ tel que $1 \leq m \leq p-1$
					\item Il choisit un entier $y$ au hasard tel que $1 \leq y \leq p-1$
					\item Bob calcule $s \defeq h^y$. $s$ est appelé "secret partagé"
					\item Il calcule $c_1 \defeq g^y$ et $c_2 \defeq m\cdot s$
					\item Il envoie le message chiffré $(c_1,c_2)$ à Alice
				\end{itemize}
				
			\paragraph{Déchiffrement}
				Alice connaît sa clé publique $(p,g,h)$, sa clé privée $x$ et le message chiffré $(c_1,c_2)$.
				\begin{itemize}
					\item Alice calcule $s \defeq c^{x}_{1}$. Comme $c_1 = g^y, c^x_1 = g^{xy} = h^y = s$, $s$ est le même nombre que celui utilisé par Bob dans le protocole de chiffrement (le secret partagé). Alice a été capable de retrouver la valeur de $s$ grâce à une exponentiation car elle connaissait $x$, mais Eve, ne connaissant pas $x$, devrait effectuer un logarithme discret pour retrouver $s$ ($s = h^y$ et $y = \log_g c_1$), ce qui demande une énorme puissance de calcul.
					\item Elle calcule $s^{-1}$, l'inverse de $s$ (voir \autoref{inverse} pour le calcul de l'inverse modulaire)  
					\item Elle calcule $m \defeq c_2 \cdot s^{-1}$. Ce calcul fonctionne et redonne le message $m$ original, car $c_1 = m \cdot s \Rightarrow c_2 \cdot s^{-1} = (m \cdot s) \cdot s^{-1} = m$
					\item Alice transforme le nombre $m$ pour reformer le message $M$
				\end{itemize}
				
		\subsubsection{Exemple numérique}
			Voici un exemple numérique de chiffrement ElGamal (pour un chiffrement efficace, nous utilisons des nombres bien plus grands que ceux utilisés ici pour faciliter la lecture):
			
			\paragraph{Génération des clés}
				Alice effectue les choix et calculs suivants pour créer sa clé publique :
				\begin{itemize}
					\item Alice choisit le modulo $p = 3457$
					\item Alice choisit $g = 3$ (le pgdc de $g$ et $p-1$ est $1$ et $g^k$ donne tous les nombres du groupe $G$
					\item Alice définit $x = 1150$ (au hasard entre $1$ et $p-1 = 3456$)
					\item Alice calcule $h \equiv 3^{1150} \equiv 2769 \pmod{3457}$
				\end{itemize}
				La clé publique d'Alice est $(p,g,h) = (3457,3,2769)$ et sa clé privée est $x = 1150$
				
			\paragraph{Chiffrement}
				Bob veut crypter le message $m = 256$ (le message est un entier compris entre $1$ et $3457$ : il n'a pas besoin de le transcrire) pour l'envoyer à Alice
				\begin{itemize}
					\item Bob définit $y = 600$ (au hasard entre $1$ et $p-1 = 3456$)
					\item Bob calcule $s \equiv h^y \equiv 2424 \pmod{3457}$
					\item Bob calcule $c_1 \equiv g^y \equiv 2753 \pmod{3457}$ et $c_2 \equiv m \cdot s \equiv 1741 \pmod{3457}$
				\end{itemize}
				Bob envoie à alice le message $(c_1,c_2) = (2753,1741)$
				
			\paragraph{Déchiffrement}
				\begin{itemize}
					\item Alice calcule $s \equiv c_1^x \equiv 2753^{1150} \equiv 2424 \pmod{3457}$. On remarque qu'il s'agit du même nombre que celui trouvé par Bob pour $s$
					\item Alice calcule $s^{-1} \equiv 1265 \pmod{3457}$ (comme expliqué dans la \autoref{inverse})
					\item Alice calcule $m \equiv c_2 \cdot s^{-1} \equiv 1741 \cdot 1265 \equiv 256 \pmod{3457}$
				\end{itemize}
				Alice a retrouvé le message d'origine $m=256$ sans jamais connaître la clé privée de Bob ($y$).\\
				
			Eve, ne connaissant ni $x$ ni $y$, aurait dû effectuer l'opération $y \equiv \log_3(2753) \pmod{3457}$ ou $x \equiv \log_3(2769) \pmod{3457}$ (donc un logarithme discret comme expliqué dans la section \autoref{discrete_log}) pour ensuite calculer $s$ et pouvoir déchiffrer le message. Ce calcul est très vite fait avec un ordinateur même en utilisant un algorithme de force brute car les nombres utilisés sont beaucoup trop petits.
		
	
	\subsection{Signatures digitales} \label{digital_signature}
		Une signature digitale est, comme une signature sur papier, un protocole qui permet d'authentifier un document par son auteur (et empêche également l'auteur de répudier le document). \cite{wiki:signatures_digitales}\\
		
		
	\subsection{Neff shuffle} \label{shuffle}
		Le mélange de Neff est une méthode présentée par Andrew Neff \cite{neff_shuffle} qui permet de mélanger des éléments cryptés par l'algorithme d'ElGamal en pouvant prouver qu'ils ont bien été mélangés et que les éléments n'ont pas été altérés.
		
	\subsection{Génération de clés distribuée} \label{DKG}
		La génération de clés distribuée (distributed key generation en anglais, abrégé DKG) est un procédé cryptographique dans lequels plusieurs parties se mettent ensemble pour générer une paire de clés publique et privée. Tout le monde peut ensuite avoir accès individuellement à la clé publique, mais chaque participant possède juste une partie de la clé privée et tous les participants doivent se mettre ensemble pour la reconstituer et déchiffrer le message \cite{wiki:DKG}.
	
	\subsection{Listes chaînées et skiplists} \label{skiplist}
		En informatique, une liste chaînée est une structure de données dans laquelle chaque cellule contient non seulement une valeur mais aussi un pointeur vers la cellule suivante, ce qui forme une chaîne \cite{wiki:linked_list}.\\
		Une skiplist est une liste chaînée qui contient, en plus des pointeurs entre chaque élément, des pointeurs entre plusieurs éléments qui ne se suivent pas, permettant ainsi de "sauter" entre plusieurs éléments lorsqu'on parcourt la liste (d'où le nom "skiplist" : liste à sauts) \cite{wiki:skiplist}.

		
	\subsection{Smart contracts} \label{smart_contracts}
		Un contrat intelligent (smart contract en anglais) a pour objectif de conclure un contrat de manière automatique sans avoir besoin d'intermédiaire. Un smart contract ne peut pas être changé une fois qu'il a été créé et tout le monde peut le consulter. Cela est possible car le smart contract est stocké dans une blockchain (en prenant la forme d'une transaction entre les deux parties du contrat). La blockchain la plus utilisée pour les smart contracts est la blockchain Ethereum, créée dans ce but à son origine. Les simples transactions de cryptomonnaie dans des blockchains, telles que Bitcoin, peuvent également être considérées comme des smart contracts réglant le droit de propriété \cite{wiki:smart_contracts}.
	
	\subsection{Problème des généraux Byzantins} \label{BFT}
		Le problème des généraux Byzantins est une métaphore pour illustrer un problème de confiance dans une communication entre deux entités \cite{wiki:BFT}.
		\paragraph{Énoncée du problème}
			Plusieurs généraux de l'armée byzantine attendent autour d'une ville qu'ils veulent attaquer. Leur but est de se coordonner, mais ils ne peuvent communiquer que grâce à des messagers. Ils doivent trouver un moyen de se mettre d'accord sur un plan d'action tout en sachant qu'il est possible qu'un ou plusieurs généraux soient des traîtres et que les messagers peuvent manquer de fiabilité \cite{wiki:BFT}.\\
			
		Dans un réseau distribué, particulièrement dans une blockchain, ce problème à une grande importance : il faut pouvoir gérer une défaillance d'un ou plusieurs n\oe uds, ou une modification malveillante des informations envoyées.\\
		
		Les deux méthodes expliquées dans la \autoref{consensus} sont des façons de résoudre ce problème \cite{wiki:BFT}.
		
		

\section{La blockchain} \label{blockchain}
	Dans cette section, nous parlerons de la blockchain, de son histoire et de son fonctionnement, principalement en prenant pour exemple sa première utilisation chronologiquement parlant : le Bitcoin.

	\subsection{Historique} \label{historique_blockchain}
		La première blockchain fonctionnelle a été conçue par une personne ou un groupe de personnes portant le pseudonyme de Satoshi Nakamoto en 2008 lors de la création du Bitcoin \cite{wiki:blockchain}.
		
	\subsection{But de la blockchain} \label{goal_blockchain}
		La blockchain est une technologie dont le but est de stocker et de transmettre des informations de manière sécurisée sans utiliser d'organe de contrôle. L'absence d'un organe de contrôle permet d'éliminer la possibilité qu'un individu ayant le contrôle sur l'ensemble des données ne puisse les modifier ou les supprimer.
		
			
	\subsection{Fonctionnement} \label{fonctionnement_blockchain}
		La blockchain est une base de données (ou un registre\footnote{Nous allons utiliser le terme "registre" comme traduction de "ledger", terme utilisé dans les travaux en anglais dans ce cas, pour la suite de cet article}) construite sur un réseau pair-à-pair (\autoref{P2P}), c'est-à-dire un réseau dans lequel, contrairement à un réseau classique du type client-serveur, chaque n\oe ud est client et serveur en même temps \cite{bitcoin} \cite{wiki:blockchain}.
		
		\subsubsection{Bloc} \label{bloc}
			Un bloc est un ensemble de données (par exemple des transactions pour l'exemple de l'application de la blockchain dans une cryptomonnaie). Il est transmis au système une fois qu'il est rempli et doit être vérifié.\\
			Chaque bloc contient une référence au bloc précédent (généralement, cette référence est le hash du bloc précédent), ce qui veut dire qu'on peut vérifier l'authenticité d'un bloc en s'appuyant sur le précédent et sur le suivant, car tous les blocs sont reliés entre eux, d'où le terme "blockchain". Pour paraître légitime en modifiant un bloc, il faut donc modifier tous les blocs précédants. Il existe plusieurs moyens pour rendre la modification des blocs compliquée, afin d'éviter la fraude \cite{bitcoin}. 
			
		
		\subsubsection{Serveur d'horodatage} \label{timestamp_server}
			Un problème à traiter est la possibilité de double dépense (ce problème est aussi valable dans un système de vote électronique) : il faut pouvoir vérifier si une personne n'a pas dépensé deux fois la même pièce. Une partie de la solution à ce problème proposée par Sakoshi Nakamoto pour le Bitcoin un serveur d'horodatage. Le but d'un serveur d'horodatage est de publier l'empreinte numérique (ou hash) d'un bloc (et de l'écrire dans un fichier accessible par tous) afin de prouver que ce bloc (et son contenu) a bien existé au moment où il a été horodaté (sinon il aurait été impossible d'obtenir son empreinte numérique). Ce fichier ne devrait pas être enregistré sur un seul serveur (pour ne pas devoir faire confiance à un seul n\oe ud, comme expliqué dans la \autoref{goal_blockchain}). Le serveur d'horodatage doit donc être implémenté dans un schéma peer-to-peer \cite{bitcoin}.
		
		\subsubsection{Méthodes de consensus} \label{consensus}
			Une méthode (ou protocole) de consensus est un procédé cryptographique qui permet de valider et de créer de nouveaux blocs sur la blockchain. On ne peut pas simplement se référer à la majorité en terme de n\oe uds pour savoir quel bloc est valide, puisqu'il est facile pour un attaquant de créer de nombreuses adresse IP sur lesquelles il fera tourner un n\oe ud \cite{bitcoin}.
			
			\paragraph{Proof of work} \label{PoW}
				La preuve de travail (proof of work en anglais, abrégé PoW) est une méthode qui demande une grande puissance de calcul à l'utilisateur voulant accéder à un service. Ce système a été initialement créé pour éviter les spams. Cette procédure consiste à faire réaliser un travail très difficile pour le n\oe ud voulant accéder, mais très facile à vérifier par un tiers. La preuve de travail est le protocole de consensus utilisé dans la blockchain Bitcoin. Puisqu'il peut y avoir plusieurs chaînes parallèles dans le Bitcoin et qu'il faut choisir laquelle est la chaîne valide, on choisira toujours la plus longue (donc celle pour laquelle la plus grande puissance de calcul a été investie). Ainsi, on ne se base pas sur la majorité des IP's, mais sur la majorité de la puissance de calcul qui est beaucoup moins facile à obtenir pour un acteur malveillant. Comme le travail doit être difficile à exécuter mais facile à vérifier, on demande souvent de retrouver quelle valeur donne un certain hash avec une certaine fonction de hashage. Pour le Bitcoin, on demande une valeur qui donne un hash commençant par un certain nombre de zéros (variable selon la difficulté voulue). Il faut ainsi une grande puissance de calcul pour résoudre ce problème, mais la solution est facilement vérifiable \cite{bitcoin}.\\
				Le problème du proof of work est qu'il demande des puissances de calcul considérables, ce qui pose un problème sur le plan écologique lorsque l'on veut que la blockchain soit utilisée largement par la population \cite{wiki:PoW}.
			\paragraph{Proof of stake} \label{PoS}
				La preuve d'enjeu ou preuve de participation (proof of stake en anglais, abrégé PoS) est une autre méthode de consensus utilisée depuis 2019 dans la blockchain de l'Ethereum, l'une des cryptomonnaies les plus utilisées. La preuve d'enjeu demande à l'utilisateur voulant valider un bloc de posséder une certaine quantité de cryptomonnaie, autrement dit on vérifie que l'utilisateur soit suffisamment impliqué dans la blockchain.\\
				Ce protocole a l'avantage, par rapport à la méthode du proof of work, de ne demander que très peu de puissance de calcul, ce qui le rend bien plus écologique \cite{wiki:PoS}.
				
				
	\subsection{Skipchain} \label{skipchain}
		Une skipchain est un type de blockchain ayant des références en avant et en arrière et dans laquelle les blocs ont également des références plus loin que leurs voisins directs (comme dans une skiplist (voir \autoref{skiplist}). Elle se différencie des blockchains de type Bitcoin dans lesquels les blocs n'ont que des références en arrière et à leur voisin direct. Cela permet à la chaine d'être lue dans les deux sens et en sautant des blocs. Le principal avantage de ce type de blockchain est que, comme il y a des liens entre des blocs très éloignés dans le temps, il n'y a pas besoin de connaître tout l'historique des transactions pour être sûr de la validité du bloc précédent (contrairement aux blockchains de type Bitcoin, avec lesquelles ils faut parfois télécharger des gigaoctets de données juste pour pouvoir se fier au dernier bloc). Dans une skipchain, les liens en arrière sont les hash des blocs précédants et les liens en avant des signature cryptographiques ajoutées après que le prochain bloc a été créé \cite{skipchain} \cite{interview}.


\section{Utiliser la blockchain pour sécuriser le vote électronique} \label{alltogether}
	
	Après avoir vu quelques principes mathématiques importants et compris le fonctionnement de la blockchain pour une cryptomonnaie, nous pouvons nous pencher sur le c\oe ur de ce travail : l'implémentation de la blockchain dans un système de vote électronique. Pour cela, nous allons prendre comme exemple le système utilisé à l'EPFL pour leurs élections. Nous n'allons pas nous concentrer sur la mise en application pratique (le frontend, comment l'utilisateur communique avec la blockchain) pour nous focaliser sur le principe théorique qui rend le tout possible.\\
	
	Un système de vote électronique basé sur la blockchain a pour but de stocker les bulletins de vote dans un registre décentralisé. Le processus de vote utilisé à l'EPFL prend la forme d'un smart contract sur la blockchain Dela\footnote{Le laboratoire de l'EPFL DEDIS (Decentralized Distributed Systems Laboratory) a développé Dela (DEDIS Ledger Architecture)} \cite{dvoting}. Cette blockchain est en fait une skipchain, afin de pouvoir plus simplement lire les résultats de l'élection \cite{evoting_epfl}. Les n\oe uds de cette blockchain sont, dans ce cas, des serveurs de plusieurs entités de l'EPFL. Pour éviter les problèmes, tous ces n\oe uds doivent être tolérants au problème byzantin (voir \autoref{BFT}). Les n\oe uds sont choisis de manière arbitraire : on connaît les entités qui font tourner un n\oe ud. Avec Dela, il faut au moins que deux tiers des n\oe uds soient bienveillants pour que l'élection fonctionne correctement : on a donc une marge d'erreur. \cite{evoting_dela} \cite{interview}
		
	\subsection{Déroulement de l'élection}
		L'élection doit suivre un déroulement et intégrer des processus précis afin de pouvoir respecter les critères mentionnés dans la \autoref{critères}.
		
		\subsubsection{Création de la clé}
			Il faut commencer par créer une clé pour crypter les votes. Afin qu'aucun n\oe ud ne puisse décrypter les bulletins tout seul, une paire de clés est créée de manière distribuée (voir \autoref{DKG}). Chaque n\oe ud obtient une partie de la clé privée et la clé publique est stockée sur la blockchain (donc accessible par tout le monde) \cite{evoting_dela}.
			
		\subsubsection{Création de l'élection}
			L'administrateur enregistre les détails de l'élection sur un contrat intelligent (voir \autoref{smart_contracts}) qu'il va ensuite stocker sur la blockchain. Les détails de l'élection sont des informations telles que le titre de l'élection, son identifiant, l'identifiant de son administrateur et les n\oe uds participant à l'élection \cite{evoting_dela}.
			
		\subsubsection{Vote}
			Chaque utilisateur\footnote{Attention, ici "utilisateur" ne veut pas dire "n\oe ud" (contrairement à la plupart des réseaux distribués) : l'utilisateur est simplement la personne qui vote et transmet son vote à un n\oe ud.} crypte son vote grâce à la clé publique et envoie son vote au n\oe ud qui le stocke dans la blockchain. À ce moment (avant le mixage), les votes sont reliables aux votants, mais encore cryptés : on ne peut pas savoir ce que chaque votant a voté \cite{evoting_dela} \cite{interview}.
			
		\subsubsection{Mixage des votes}
			Le mixage des votes se fait grâce au mixage de Neff (voir \autoref{shuffle}) par tous les n\oe uds après que l'administrateur a fermé l'élection (chaque n\oe ud effectue un mixage lui-même, les votes sont donc mixés une fois par tous les n\oe uds). En utilisant le mixage de Neff, il est possible de mélanger des votes chiffrés de telle manière que, premièrement, on ne puisse pas savoir quel vote appartient à qui et, deuxièmement, qu'il soit possible de prouver que ce mélange n'a pas changé les votes \cite{evoting_dela} \cite{interview}. 
			
		\subsubsection{Décryptage et publication}
			Pour finir, les votes sont décryptés et publiés. Le déchiffrement se fait grâce aux parties de clé privée. Les parties de clé privée ne sont pas réunies par un seul n\oe ud, ce qui lui permettrait de déchiffrer lui-même les votes, mais les votes sont déchiffrés grâce à la collaboration de tous les n\oe uds. C'est ici qu'apparaît le protocole de consensus utilisé dans ce système. Ce protocole est un t-of-n (threshold of nodes, "seuil de n\oe uds" en français). Chaque n\oe ud vérifie, avant d'apporter sa contribution au décryptage, que le mixage a bien été effectué. Dans le système utilisé à l'EPFL, il faut au moins que 5 n\oe uds sur 7 au total soient d'accord pour déchiffrer les votes. Cependant, la proportion des n\oe uds devant participer au déchiffrement, afin que celui-ci soit possible, est variable (elle est définie lors de la génération des clefs). Puisque nous partons du principe que jusqu'à un tiers des n\oe uds peuvent être malveillants, il serait possible de générer les clefs tel qu'il faudrait seulement deux tiers des n\oe uds participants pour réussir à déchiffrer les votes. Comme les votes ont été mélangés à l'étape précédente, on peut les décrypter sans risquer de compromettre la confidentialité, puisqu'ils ne peuvent plus être reliés aux votants \cite{evoting_dela} \cite{interview}.\\
			
		
	\subsection{Sécurité et fiabilité de ce système}
		Comme ce système repose sur Dela, jusqu'à un tiers des n\oe uds peuvent être maléfiques sans compromettre le vote. Pour le processus de mixage, il en faut au moins un fiable pour que cette partie se passe correctement, puisque chaque n\oe ud procède à un mixage. Le cryptage par clés distribuées a une tolérance variable. Aucun problème de sécurité n'est causé par une tolérance trop faible, puisque les n\oe uds malveillants peuvent juste bloquer le décryptage et non le forcer ou empêcher un bon cryptage. Le système peut donc tolérer dans son ensemble jusqu'à un tiers de n\oe uds malveillants avant d'avoir des problèmes de sécurité \cite{evoting_dela}.\\
		
		Le gros problème de sécurité de ce système ne réside pas dans la blockchain ou les processus cryptographiques, mais plutôt dans la façon qu'ont les utilisateurs de communiquer avec la blockchain et l'authentification des utilisateurs. Comme les utilisateurs du système (les votants) ne sont pas eux-mêmes des n\oe uds, ils doivent communiquer avec un n\oe ud afin de pouvoir soumettre un vote.
		
		\paragraph{Attaque man-in-the-middle}
			Comme la communication entre les utilisateurs et les n\oe uds se fait grâce au protocole HTTP, qui n'est pas chiffré, elle est vulnérable à une attaque "man-in-the-middle". Une attaque "man-in-the-middle" (littéralement "homme au milieu") est une attaque informatique où l'attaquant se place comme intermédiaire entre deux parties communiquant ensemble en faisant croire aux deux personnes qu'elles communiquent bien entre elles. Cette attaque permet à l'attaquant, lors de l'utilisation d'un protocole de communication non crypté, de lire les messages et de les changer \cite{wiki:mitm}. Ce problème peut être résolu en utilisant le protocole HTTPS à la place \cite{evoting_dela}.\\
			
		Comme un utilisateur communique directement avec un n\oe ud pour soumettre son vote, si ce n\oe ud est malveillant, il peut ne pas soumettre le vote de l'utilisateur. Le même problème vaut également pour un utilisateur qui veut regarder le contenu de la blockchain : il doit demander à un n\oe ud potentiellement malveillant qui pourrait lui fournir de fausses informations (ces informations peuvent être les résultats de l'élection). On pourrait penser que le n\oe ud n'a pas la possibilité de voir le vote de l'utilisateur, puisque ce dernier le chiffre lui-même avant de l'envoyer. Le problème est que l'utilisateur chiffre son vote avec la clé qu'il a obtenue depuis la blockchain, donc par l'intermédiaire d'un n\oe ud. Le n\oe ud peut donc lui donner une clé publique dont il possède la clé privée, ce qui lui donne la possibilité de voir le vote de l'utilisateur. De plus, comme le n\oe ud a la possibilité de bloquer un vote et connaît la clé publique de l'élection, il peut changer le vote d'un utilisateur. Cela ne serait pas un problème si chaque utilisateur était lui-même un n\oe ud de la blockchain. Ce n'est malheureusement pas possible car héberger un n\oe ud demande des ressources considérables (en matière de puissance de calcul et de stockage) et une connexion internet fiable pendant toute l'élection. Il faudrait également rendre le processus d'installation d'un serveur plus facile. Une solution applicable serait d'obliger les utilisateurs à communiquer avec plusieurs n\oe uds (au moins deux tiers des n\oe uds pour avoir la même tolérance que le reste du système) et vérifier qu'ils donnent tous les mêmes informations \cite{evoting_dela}.\\
		
		L'authentification des utilisateurs pose également problème. Pour l'instant, le processus d'authentification passe par le serveur d'authentification de l'EPFL. Il faut donc faire confiance à un serveur centralisé. Un administrateur système malveillant pourrait voter au nom de quelqu'un et empêcher un utilisateur de voter. Pour résoudre ce problème, il faudrait avoir recours à un serveur d'authentification distribué (qui est un défi supplémentaire) \cite{evoting_epfl} \cite{interview}.

\section{Conclusion}
	Pour conclure, nous avons vu que la blockchain offre de très bonnes possibilités en  matière de stockage sécurisé de données, que ce soient des transactions financières ou des bulletins de vote électroniques. Il y a certes encore des problèmes de sécurité, mais ce sont plus des problèmes d'implémentation que des failles cryptographiques dans le principe de base. De plus, la blockchain nous permet de nous passer du principe de confiance, ce qui n'est pas facile à faire. Nous pouvons donc affirmer que la blockchain est une technologie qui peut très bien être utilisée pour héberger un système de vote électronique. Nous avons vu les principes théoriques d'une application concrète de cette technologie au domaine des votations, ce qui répond à notre question initiale.\\
	
	Cependant, même si ce système est très prometteur, il faut toujours se poser la question de savoir comment l'implémenter avant de l'utiliser réellement. Si les appareils sur lesquels les citoyens votent ne sont pas correctement sécurisés, le vote ne le sera pas, même si le logiciel utilisé pour voter n'a pas de failles. C'est un des problèmes subsistants encore, sur lesquels les communautés scientifiques et techniques devront se pencher à l'avenir afin que nous puissions un jour utiliser le vote électronique à grande échelle.
	
\section*{Remerciements}
	Ce travail n'aurait pas été réalisable sans l'aide précieuse de plusieurs personnes, que je tiens à remercier chaleureusement. \\
	 Enea Milio, qui a été mon mentor durant ce travail et qui m'a beaucoup aidé pour la partie mathématique, l'informatique théorique sur lequel se base ce travail et la partie organisationnelle.\\
	 Linus Gasser, qui a eu la gentillesse de m'accorder une entrevue durant laquelle j'ai pu lui poser mes questions concernant le système d'e-voting à l'EPFL.

\bibliography{tm}
\bibliographystyle{ieeetr}

\listoffigures
\listoftables

	
\end{document}